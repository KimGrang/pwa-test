<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>브라우저에서 실행하는 GGUF 챗봇 (로컬 전용)</title>
  <style>
    :root { --bg:#0b1020; --card:#111937; --ink:#e8ecff; --muted:#9aa3c7; --accent:#7aa2ff; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,Arial}
    header{position:sticky;top:0;background:linear-gradient(180deg, rgba(11,16,32,.95), rgba(11,16,32,.6));backdrop-filter: blur(6px);z-index:5;border-bottom:1px solid #1c2447}
    .wrap{max-width:1100px;margin:0 auto;padding:16px}
    .grid{display:grid;gap:12px}
    .cols{grid-template-columns:1fr 1fr}
    .card{background:var(--card);border:1px solid #1f2a52;border-radius:16px;padding:14px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    input[type="text"],textarea{width:100%;padding:10px;border-radius:10px;background:#0e1530;border:1px solid #1e2a55;color:var(--ink)}
    textarea{min-height:80px}
    button{appearance:none;border:1px solid #2a3a78;background:#152253;color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer}
    button.primary{background:var(--accent);border-color:#5a7ee6;color:#07122b;font-weight:600}
    button:disabled{opacity:.5;cursor:not-allowed}
    .log{height:340px;overflow:auto;background:#0a1128;border:1px solid #1e2a55;border-radius:12px;padding:10px;white-space:pre-wrap}
    .msg{padding:10px 12px;border-radius:12px;margin:10px 0;max-width:85%}
    .user{background:#23304f;margin-left:auto}
    .bot{background:#121a3a}
    .status{color:var(--muted);font-size:12px}
    .badge{display:inline-block;padding:2px 8px;border:1px solid #2a3a78;border-radius:999px;font-size:12px;color:#b9c6ff}
    .overlay{position:fixed;inset:0;background:rgba(5,10,25,.65);backdrop-filter:blur(2px);display:none;align-items:center;justify-content:center;z-index:99}
    .overlay.show{display:flex}
    .overlay-box{min-width:260px;max-width:90vw;background:var(--card);border:1px solid #1f2a52;border-radius:16px;padding:18px 20px;box-shadow:0 10px 30px rgba(0,0,0,.45);display:flex;flex-direction:column;gap:10px;align-items:center}
    .spinner{width:40px;height:40px;border:4px solid rgba(122,162,255,.25);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body>
  <header>
    <div class="wrap row" style="justify-content:space-between;align-items:center">
      <div class="row" style="gap:6px">
        <span class="badge">브라우저 전용 · GGUF</span>
        <span class="status" id="status">모델 미로드</span>
      </div>
      <div class="row" style="gap:10px">
        <span class="status">TTFT: <span id="ttft">-</span></span>
        <span class="status">총 소요: <span id="tgen">-</span></span>
      </div>
    </div>
  </header>

  <main class="wrap grid" style="margin-top:10px">
    <section class="card grid cols">
      <div>
        <h3>1) 내 GGUF 파일 로드 (로컬)</h3>
        <div class="grid">
          <input id="file" type="file" accept=".gguf" multiple />
          <div class="row">
            <button id="btnLoadLocal" class="primary">로컬 GGUF 로드</button>
            <button id="btnUnload">언로드</button>
          </div>
          <div class="row" style="gap:8px;align-items:center">
            <progress id="pbar" value="0" max="100" style="display:none;width:200px;height:10px;"></progress>
            <span id="ptext" class="status"></span>
          </div>
          <div class="status" id="fileInfo"></div>
          <small class="status">분할 GGUF라면 모든 조각을 함께 선택하세요 (예: ...-00001-of-00005.gguf 등).</small>
        </div>
      </div>
      <div>
        <h3>옵션</h3>
        <div class="grid">
          <label>시스템 프롬프트</label>
          <textarea id="system">당신은 한국어를 잘하는 유능한 오픈소스 LLM입니다. 간결하고 정확하게 답하세요.</textarea>
          <div class="row">
            <label>토큰 수 (n_predict): <input id="nPredict" type="number" value="128" style="width:100px"></label>
            <label>온도: <input id="temp" type="number" step="0.05" value="0.7" style="width:80px"></label>
            <label>top_p: <input id="topP" type="number" step="0.05" value="0.9" style="width:80px"></label>
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="log" id="chat"></div>
      <div class="grid" style="margin-top:8px">
        <textarea id="input" placeholder="메시지를 입력하세요..."></textarea>
        <div class="row">
          <button id="btnSend" class="primary" disabled>보내기</button>
          <button id="btnStop" style="display:none">중지</button>
          <button id="btnClear">대화 지우기</button>
        </div>
      </div>
    </section>
  </main>

  <!-- 모델 로딩 오버레이 -->
  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="overlay-box">
      <div class="spinner"></div>
      <div id="overlayText" class="status">로딩 중…</div>
    </div>
  </div>

  <script type="module">
    // 팁: file:// 이 아니라 http://localhost 로 여세요. (ESM/CORS/워커 제약 회피)
    import { Wllama, LoggerWithoutDebug } from 'https://cdn.jsdelivr.net/npm/@wllama/wllama@2.3.4/esm/index.js';

    // ⚠ 멀티스레드 워커를 쓰면 COOP/COEP 없을 때 에러가 나와요.
    //    아래처럼 "single-thread"만 지정해서 워커 자체를 안 쓰도록 강제합니다.
    const WasmPaths = {
      'single-thread/wllama.wasm': 'https://cdn.jsdelivr.net/npm/@wllama/wllama@2.3.4/esm/single-thread/wllama.wasm'
      // 'multi-thread/wllama.wasm' 는 의도적으로 생략 (워커 생성 안 함)
    };

    // ---- UI refs
    const statusEl  = document.getElementById('status');
    const chatEl    = document.getElementById('chat');
    const btnSend   = document.getElementById('btnSend');
    const btnStop   = document.getElementById('btnStop');
    const btnClear  = document.getElementById('btnClear');
    const btnLoad   = document.getElementById('btnLoadLocal');
    const btnUnload = document.getElementById('btnUnload');
    const pbar   = document.getElementById('pbar');
    const ptext  = document.getElementById('ptext');
    const fileEl = document.getElementById('file');
    const fileInfo = document.getElementById('fileInfo');
    const sysEl  = document.getElementById('system');
    const inputEl= document.getElementById('input');
    const nPredEl= document.getElementById('nPredict');
    const tempEl = document.getElementById('temp');
    const topPEl = document.getElementById('topP');
    const ttftEl = document.getElementById('ttft');
    const tgenEl = document.getElementById('tgen');

    // ---- 오버레이 (모델 로딩만)
    const overlay = document.getElementById('overlay');
    const overlayText = document.getElementById('overlayText');
    function overlayShow(text){
      overlayText.textContent = text || '로딩 중…';
      overlay.classList.add('show');
      overlay.setAttribute('aria-hidden','false');
      document.body.style.pointerEvents = 'none';
    }
    function overlayHide(){
      overlay.classList.remove('show');
      overlay.setAttribute('aria-hidden','true');
      document.body.style.pointerEvents = '';
    }

    function showProgress(val, text){
      if(typeof val === 'number'){ pbar.style.display='inline-block'; pbar.value = Math.max(0, Math.min(100, val)); }
      else { pbar.style.display='none'; }
      if(text){ ptext.textContent = text; }
    }
    function hideProgress(){ pbar.style.display='none'; ptext.textContent=''; }
    function logStatus(msg){ statusEl.textContent = msg; }
    function appendMsg(role, text){
      const div = document.createElement('div');
      div.className = 'msg ' + (role === 'user' ? 'user' : 'bot');
      div.textContent = text;
      chatEl.appendChild(div);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    // ---- 상태
    const wllama = new Wllama(WasmPaths, { logger: LoggerWithoutDebug });
    let modelLoaded = false;
    let modelLoading = false;
    let history = [];
    let genAbortCtrl = null;
    let generating = false;

    async function loadFromLocalFile(){
      if(modelLoading) return;
      const files = fileEl.files ? Array.from(fileEl.files) : [];
      if(files.length === 0){ alert('GGUF 파일을 선택하세요'); return; }

      const totalMB = (files.reduce((s,f)=>s+f.size,0)/1024/1024).toFixed(1);
      fileInfo.textContent = `선택됨: ${files.length}개, 총 ${totalMB} MB`;

      btnSend.disabled = true;
      modelLoading = true;
      logStatus('로컬 모델 로딩 중…');
      showProgress(null, '파일 읽는 중…');
      overlayShow('로컬 모델 로딩 중…');

      try{
        await wllama.loadModel(files, { n_ctx: 2048 }); // 여유되면 4096
        modelLoaded = true;
        logStatus('모델 로드 완료');
        btnSend.disabled = false;
      }catch(err){
        console.error(err);
        alert('모델 로드 실패: ' + (err?.message || err));
        logStatus('모델 미로드');
      }finally{
        modelLoading = false;
        hideProgress();
        overlayHide();
      }
    }

    function buildMessages(){
      const msgs = [{ role:'system', content: sysEl.value.trim() }];
      for(const m of history){ msgs.push({ role: m.role, content: m.content }); }
      return msgs;
    }

    async function send(){
      if(generating) return;
      const text = inputEl.value.trim();
      if(!text) return;
      if(!modelLoaded){ alert('먼저 모델을 로드하세요'); return; }

      // 측정 시작
      const tStart = performance.now();
      ttftEl.textContent = '측정 중…';
      tgenEl.textContent = '측정 중…';

      history.push({ role:'user', content:text });
      appendMsg('user', text);
      inputEl.value = '';

      appendMsg('assistant', ''); // 스트리밍으로 채울 자리
      const placeholder = chatEl.lastElementChild;

      const nPredict = Math.min(Number(nPredEl.value)||128, 512);
      const sampling = { temp:Number(tempEl.value)||0.7, top_p:Number(topPEl.value)||0.9, top_k:40 };

      genAbortCtrl = new AbortController();
      generating = true;
      btnSend.disabled = true;
      btnStop.style.display = 'inline-block';

      try{
        const stream = await wllama.createChatCompletion(
          buildMessages(),
          { nPredict, sampling, useCache:false, stream:true, abortSignal: genAbortCtrl.signal }
        );

        let firstChunkSeen = false;
        for await (const chunk of stream){
          if(!firstChunkSeen){
            firstChunkSeen = true;
            const ms = performance.now() - tStart;
            ttftEl.textContent = (ms/1000).toFixed(2) + 's'; // TTFT 표시
          }
          placeholder.textContent = chunk.currentText || '';
          chatEl.scrollTop = chatEl.scrollHeight;
        }

        // 총 소요
        const totalMs = performance.now() - tStart;
        tgenEl.textContent = (totalMs/1000).toFixed(2) + 's';

        history.push({ role:'assistant', content: placeholder.textContent });
      }catch(err){
        if (err && (err.name === 'AbortError' || String(err).includes('Abort'))){
          console.warn('생성 중지됨');
          const totalMs = performance.now() - tStart;
          tgenEl.textContent = (totalMs/1000).toFixed(2) + 's';
        } else {
          placeholder.textContent = '[오류] ' + err;
          console.error(err);
          ttftEl.textContent = '-';
          tgenEl.textContent = '-';
        }
      }finally{
        generating = false;
        btnSend.disabled = false;
        btnStop.style.display = 'none';
        genAbortCtrl = null;
      }
    }

    function stop(){ try{ genAbortCtrl?.abort(); }catch{} }

    async function unload(){
      try{
        await (wllama.unload?.() ?? wllama.exit?.());
        modelLoaded = false; btnSend.disabled = true;
        logStatus('모델 언로드 완료');
      }catch(e){ console.warn(e); }
    }

    // 이벤트
    document.getElementById('btnLoadLocal').addEventListener('click', loadFromLocalFile);
    document.getElementById('file').addEventListener('change', loadFromLocalFile);
    document.getElementById('btnUnload').addEventListener('click', unload);
    btnSend.addEventListener('click', send);
    btnStop.addEventListener('click', stop);
    btnClear.addEventListener('click', ()=>{ history=[]; chatEl.innerHTML=''; });

    logStatus('모델 미로드');
  </script>
</body>
</html>
